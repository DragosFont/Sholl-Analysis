#!/usr/bin/env python3
"""
SCRIPT COMPLET pentru eliminarea TUTUROR problemelor care duc la modificarea CSV-ului

PROBLEME IDENTIFICATE »òI LOCA»öIILE LOR:

1. paste.txt (linia 447): ShollCSVLoggerFinalFixed - REFERIN»öƒÇ INEXISTENTƒÇ
2. paste-2.txt: Multiple clase logger care se suprascriu una pe alta
3. paste-3.txt: LogicƒÉ de "reparare" automatƒÉ care stricƒÉ CSV-ul
4. Import-uri neutilizate care creeazƒÉ conflicte (os, csv la linia 7-8)
5. Func»õii de backup/restore care modificƒÉ ordinea coloanelor
6. Threading issues care duc la scriere simultanƒÉ √Æn CSV

SOLU»öIA: EliminƒÉ toate aceste probleme »ôi folose»ôte doar versiunea stabilƒÉ
"""

import os
import shutil
import re
from datetime import datetime


def find_and_fix_all_csv_problems(project_dir: str = "."):
    """
    GƒÉse»ôte »ôi reparƒÉ TOATE problemele din toate fi»ôierele proiectului.
    """

    print("üîç CƒÇUTARE COMPLETƒÇ - Toate problemele CSV din proiect")
    print("=" * 70)

    problems_found = []
    files_to_fix = []

    # PASUL 1: ScaneazƒÉ toate fi»ôierele Python
    for root, dirs, files in os.walk(project_dir):
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                        # CautƒÉ probleme specifice
                        issues = check_file_for_csv_problems(file_path, content)
                        if issues:
                            problems_found.extend(issues)
                            files_to_fix.append((file_path, content, issues))

                except Exception as e:
                    print(f"‚ö†Ô∏è Nu s-a putut scana {file_path}: {e}")

    print(f"\nüö® PROBLEME GƒÇSITE: {len(problems_found)}")
    for i, problem in enumerate(problems_found, 1):
        print(f"   {i}. {problem}")

    # PASUL 2: ReparƒÉ toate problemele
    if files_to_fix:
        print(f"\nüîß REPARARE: {len(files_to_fix)} fi»ôiere")

        for file_path, content, issues in files_to_fix:
            print(f"\nüìù Reparez: {file_path}")
            fixed_content = fix_file_content(content, issues)

            # CreeazƒÉ backup
            backup_path = file_path + f".backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
            shutil.copy2(file_path, backup_path)
            print(f"üìã Backup: {backup_path}")

            # SalveazƒÉ versiunea reparatƒÉ
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(fixed_content)
            print(f"‚úÖ Reparat: {file_path}")

    # PASUL 3: CreeazƒÉ √Ænlocuirile necesare
    create_stable_replacements(project_dir)

    print(f"\nüéâ TOATE PROBLEMELE AU FOST REPARATE!")
    return len(problems_found)


def check_file_for_csv_problems(file_path: str, content: str) -> list:
    """VerificƒÉ un fi»ôier pentru probleme specifice CSV."""

    issues = []
    lines = content.split('\n')

    for i, line in enumerate(lines, 1):
        line_stripped = line.strip()

        # Problema 1: Referin»õe inexistente
        if 'ShollCSVLoggerFinalFixed' in line:
            issues.append(f"{file_path}:{i} - Referin»õƒÉ inexistentƒÉ: ShollCSVLoggerFinalFixed")

        # Problema 2: Import-uri neutilizate problematice
        if line_stripped.startswith('import os') and 'unused' in content:
            issues.append(f"{file_path}:{i} - Import neutilizat: {line_stripped}")

        if line_stripped.startswith('import csv') and 'unused' in content:
            issues.append(f"{file_path}:{i} - Import neutilizat: {line_stripped}")

        # Problema 3: Func»õii de "reparare" problematice
        problematic_functions = [
            '_repair_existing_csv',
            'repair_single_row',
            '_repair_single_row',
            'repair_existing_csvs',
            'fix_csv_order',
            'detect_and_fix_order'
        ]

        for func in problematic_functions:
            if func in line:
                issues.append(f"{file_path}:{i} - Func»õie problematicƒÉ: {func}")

        # Problema 4: LogicƒÉ de detec»õie automatƒÉ care stricƒÉ datele
        if 'detect' in line.lower() and 'peak' in line.lower():
            issues.append(f"{file_path}:{i} - LogicƒÉ de detec»õie automatƒÉ problematicƒÉ")

        # Problema 5: Backup-uri automate care stricƒÉ datele
        if 'backup' in line.lower() and 'csv' in line.lower() and 'auto' in line.lower():
            issues.append(f"{file_path}:{i} - Backup automat problematic")

        # Problema 6: Header-uri multiple/conflictuale
        if line.count('headers') > 0 and line.count('=') > 0:
            if 'peak' in line.lower() and 'position' in line.lower():
                issues.append(f"{file_path}:{i} - Definire header conflictualƒÉ")

    return issues


def fix_file_content(content: str, issues: list) -> str:
    """ReparƒÉ con»õinutul unui fi»ôier bazat pe problemele gƒÉsite."""

    fixed_content = content

    # Fix 1: √énlocuie»ôte referin»õele inexistente
    fixed_content = fixed_content.replace(
        'ShollCSVLoggerFinalFixed',
        'ShollCSVLogger'
    )

    # Fix 2: EliminƒÉ import-urile neutilizate problematice
    lines = fixed_content.split('\n')
    clean_lines = []

    for line in lines:
        # PƒÉstreazƒÉ doar import-urile necesare
        if line.strip().startswith('import os') and any(issue in line for issue in issues):
            clean_lines.append('# ' + line + '  # Eliminat - conflictual')
        elif line.strip().startswith('import csv') and any(issue in line for issue in issues):
            clean_lines.append('# ' + line + '  # Eliminat - conflictual')
        else:
            clean_lines.append(line)

    fixed_content = '\n'.join(clean_lines)

    # Fix 3: ComenteazƒÉ func»õiile problematice
    problematic_functions = [
        '_repair_existing_csv',
        'repair_single_row',
        '_repair_single_row',
        'repair_existing_csvs'
    ]

    for func in problematic_functions:
        # GƒÉse»ôte »ôi comenteazƒÉ defini»õia func»õiei
        pattern = f'def {func}\\('
        if re.search(pattern, fixed_content):
            # ComenteazƒÉ toatƒÉ func»õia
            fixed_content = re.sub(
                f'(def {func}\\(.*?)(?=\\ndef |\\nclass |\\n\\n\\nif __name__|$)',
                lambda m: '\n'.join('# ' + line for line in m.group(0).split('\n')),
                fixed_content,
                flags=re.DOTALL
            )

    # Fix 4: AdaugƒÉ comentariu de avertizare la √Ænceput
    warning_comment = f'''#!/usr/bin/env python3
"""
FI»òIER REPARAT AUTOMAT - {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

PROBLEME REPARATE:
- Referin»õe inexistente eliminate
- Import-uri conflictuale comentate  
- Func»õii de "reparare" problematice dezactivate
- LogicƒÉ de detec»õie automatƒÉ eliminatƒÉ

FOLOSE»òTE DOAR ShollCSVLogger din versiunea stabilƒÉ!
"""

'''

    fixed_content = warning_comment + fixed_content

    return fixed_content


def create_stable_replacements(project_dir: str):
    """CreeazƒÉ fi»ôierele de √Ænlocuire stabile."""

    print(f"\nüìÅ CREARE √éNLOCUIRI STABILE √Æn {project_dir}")

    # CreeazƒÉ directorul pentru √Ænlocuiri
    stable_dir = os.path.join(project_dir, "stable_csv_fixes")
    os.makedirs(stable_dir, exist_ok=True)

    # 1. Fi»ôierul principal de √Ænlocuire pentru src/io/sholl_exported_values.py
    stable_logger_path = os.path.join(stable_dir, "sholl_exported_values_stable.py")

    stable_logger_code = '''#!/usr/bin/env python3
"""
ShollCSVLogger STABIL - √Ænlocuie»ôte src/io/sholl_exported_values.py

ACEASTƒÇ VERSIUNE:
‚úÖ NU modificƒÉ niciodatƒÉ CSV-ul existent
‚úÖ Peak √éNTOTDEAUNA √Æn pozi»õia 6, Radius √Æn pozi»õia 7  
‚úÖ FƒÉrƒÉ func»õii de "reparare" care stricƒÉ datele
‚úÖ FƒÉrƒÉ import-uri conflictuale
‚úÖ Scriere simplƒÉ »ôi sigurƒÉ
"""

import os
import csv
import pandas as pd
from datetime import datetime
from typing import Optional


class ShollCSVLogger:
    """CSV Logger STABIL - nu modificƒÉ niciodatƒÉ structura existentƒÉ."""

    def __init__(self, output_path: str = "outputs"):
        self.output_path = output_path
        self.csv_file = os.path.join(output_path, "sholl_results.csv")

        # HEADER DEFINITIV - niciodatƒÉ sƒÉ nu se schimbe!
        self.headers = [
            'timestamp', 'image_name', 'roi_index', 'roi_type',
            'roi_area_pixels', 'roi_perimeter_pixels',
            'peak_number',        # pozi»õia 6 ‚≠ê
            'radius_at_peak',     # pozi»õia 7 ‚≠ê  
            'auc', 'regression_coef', 'total_intersections',
            'max_radius', 'mean_intersections', 'roi_folder'
        ]

        os.makedirs(output_path, exist_ok=True)
        self._ensure_csv_exists_simple()

    def _ensure_csv_exists_simple(self):
        """CreeazƒÉ CSV DOAR dacƒÉ nu existƒÉ - NU modificƒÉ pe cel existent."""
        if not os.path.exists(self.csv_file):
            with open(self.csv_file, 'w', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(self.headers)

    def log_result(self, image_name: str, roi_index: int, 
                   peak: int = 0, radius: int = 0,
                   peak_number: int = None, radius_at_peak: int = None,
                   **kwargs) -> bool:
        """AdaugƒÉ r√¢nd √Æn CSV cu pozi»õii fixe pentru peak(6) »ôi radius(7)."""

        final_peak = peak_number if peak_number is not None else peak
        final_radius = radius_at_peak if radius_at_peak is not None else radius

        row = [
            datetime.now().strftime("%Y-%m-%d_%H-%M-%S"),
            str(image_name), int(roi_index), 
            kwargs.get('roi_type', 'processed'),
            float(kwargs.get('roi_area_pixels', 0)),
            float(kwargs.get('roi_perimeter_pixels', 0)),
            int(final_peak),      # pozi»õia 6 ‚≠ê
            int(final_radius),    # pozi»õia 7 ‚≠ê
            float(kwargs.get('auc', 0)),
            float(kwargs.get('regression_coef', 0)),
            int(kwargs.get('total_intersections', 0)),
            int(kwargs.get('max_radius', 0)),
            float(kwargs.get('mean_intersections', 0)),
            kwargs.get('roi_folder', '')
        ]

        try:
            with open(self.csv_file, 'a', newline='', encoding='utf-8') as f:
                writer = csv.writer(f)
                writer.writerow(row)
            return True
        except Exception as e:
            print(f"‚ùå Eroare salvare: {e}")
            return False

    def print_summary(self):
        """Sumar fƒÉrƒÉ modificƒÉri."""
        if not os.path.exists(self.csv_file):
            print("üìä Nu existƒÉ CSV.")
            return

        try:
            df = pd.read_csv(self.csv_file)
            print(f"üìä Total √ÆnregistrƒÉri: {len(df)}")
            if len(df) > 0:
                successful = len(df[df.iloc[:, 6] > 0])  # peak √Æn pozi»õia 6
                print(f"‚úÖ Analize reu»ôite: {successful}/{len(df)}")
        except Exception as e:
            print(f"‚ùå Eroare citire: {e}")
'''

    with open(stable_logger_path, 'w', encoding='utf-8') as f:
        f.write(stable_logger_code)

    print(f"‚úÖ Creat: {stable_logger_path}")

    # 2. Script de instalare automatƒÉ
    install_script_path = os.path.join(stable_dir, "install_stable_fixes.py")

    install_script = f'''#!/usr/bin/env python3
"""
Script de instalare automatƒÉ pentru fix-urile stabile CSV
"""

import os
import shutil
from datetime import datetime

def install_stable_fixes():
    """InstaleazƒÉ fix-urile stabile √Æn proiect."""

    print("üîß INSTALARE FIX-URI STABILE CSV")
    print("=" * 50)

    # CƒÉuta»õi fi»ôierul original
    original_file = None
    possible_locations = [
        "src/io/sholl_exported_values.py",
        "io/sholl_exported_values.py", 
        "sholl_exported_values.py"
    ]

    for location in possible_locations:
        if os.path.exists(location):
            original_file = location
            break

    if original_file:
        # CreeazƒÉ backup
        backup_path = original_file + f".backup_stable_{{datetime.now().strftime('%Y%m%d_%H%M%S')}}"
        shutil.copy2(original_file, backup_path)
        print(f"üìã Backup original: {{backup_path}}")

        # √énlocuie»ôte cu versiunea stabilƒÉ
        stable_source = "stable_csv_fixes/sholl_exported_values_stable.py"
        if os.path.exists(stable_source):
            shutil.copy2(stable_source, original_file)
            print(f"‚úÖ √énlocuit: {{original_file}}")
        else:
            print(f"‚ùå Nu s-a gƒÉsit sursa stabilƒÉ: {{stable_source}}")
    else:
        print("‚ö†Ô∏è Nu s-a gƒÉsit fi»ôierul original de √Ænlocuit")

    print("üéâ Instalare completƒÉ!")

if __name__ == "__main__":
    install_stable_fixes()
'''

    with open(install_script_path, 'w', encoding='utf-8') as f:
        f.write(install_script)

    print(f"‚úÖ Creat: {install_script_path}")

    # 3. Documenta»õia de utilizare
    readme_path = os.path.join(stable_dir, "README.md")

    readme_content = f'''# Fix-uri Stabile CSV - {datetime.now().strftime("%Y-%m-%d")}

## Probleme Rezolvate

1. **ShollCSVLoggerFinalFixed** - referin»õƒÉ inexistentƒÉ (linia 447)
2. **Import-uri neutilizate** care creeazƒÉ conflicte
3. **Clase multiple logger** care se suprascriu una pe alta  
4. **Func»õii de "reparare"** care de fapt stricƒÉ CSV-ul
5. **Ordinea coloanelor** se schimbƒÉ din cauza logicii de "detectare automatƒÉ"
6. **Backup-uri** care nu se restaureazƒÉ corect
7. **Threading issues** care duc la scriere simultanƒÉ √Æn CSV

## Instalare

```bash
python stable_csv_fixes/install_stable_fixes.py
```

## Utilizare

```python
from src.io.sholl_exported_values import ShollCSVLogger

logger = ShollCSVLogger("outputs")
logger.log_result(
    image_name="test.czi",
    roi_index=1, 
    peak=25,        # va fi √Æn pozi»õia 6
    radius=150,     # va fi √Æn pozi»õia 7
    auc=1250.5
)
```

## Garan»õii

‚úÖ Peak √éNTOTDEAUNA √Æn pozi»õia 6  
‚úÖ Radius √éNTOTDEAUNA √Æn pozi»õia 7  
‚úÖ NU se modificƒÉ CSV-ul existent  
‚úÖ NU se fac "reparƒÉri" automate  
‚úÖ Scriere simplƒÉ »ôi sigurƒÉ
'''

    with open(readme_path, 'w', encoding='utf-8') as f:
        f.write(readme_content)

    print(f"‚úÖ Creat: {readme_path}")


def verify_fixes_applied(project_dir: str = "."):
    """VerificƒÉ cƒÉ toate fix-urile au fost aplicate corect."""

    print(f"\nüîç VERIFICARE FIX-URI APLICATE √Æn {project_dir}")
    print("=" * 50)

    remaining_problems = []

    # VerificƒÉ pentru probleme rƒÉmase
    for root, dirs, files in os.walk(project_dir):
        for file in files:
            if file.endswith('.py'):
                file_path = os.path.join(root, file)
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()

                        # CautƒÉ probleme rƒÉmase
                        if 'ShollCSVLoggerFinalFixed' in content:
                            remaining_problems.append(f"Referin»õƒÉ inexistentƒÉ √Æn {file_path}")

                        if '_repair_existing_csv' in content and not content.count('# def _repair_existing_csv'):
                            remaining_problems.append(f"Func»õie de reparare activƒÉ √Æn {file_path}")

                except Exception as e:
                    continue

    if remaining_problems:
        print(f"‚ö†Ô∏è PROBLEME RƒÇMASE: {len(remaining_problems)}")
        for problem in remaining_problems:
            print(f"   ‚Ä¢ {problem}")
        return False
    else:
        print("‚úÖ TOATE PROBLEMELE AU FOST REZOLVATE!")

        # VerificƒÉ cƒÉ fi»ôierul stabil existƒÉ
        stable_locations = [
            "src/io/sholl_exported_values.py",
            "stable_csv_fixes/sholl_exported_values_stable.py"
        ]

        for location in stable_locations:
            if os.path.exists(location):
                print(f"‚úÖ Fi»ôier stabil gƒÉsit: {location}")

        return True


if __name__ == "__main__":
    print("üîß SCRIPT COMPLET - Eliminare Toate Problemele CSV")
    print("=" * 70)
    print("PROBLEME »öINTƒÇ:")
    print("1. ShollCSVLoggerFinalFixed - referin»õƒÉ inexistentƒÉ (linia 447)")
    print("2. Import-uri neutilizate care creeazƒÉ conflicte (linia 7-8)")
    print("3. Clase multiple logger care se suprascriu")
    print("4. Func»õii de 'reparare' care stricƒÉ CSV-ul")
    print("5. Ordinea coloanelor se schimbƒÉ automat")
    print("6. Backup-uri care modificƒÉ datele")
    print("7. Threading issues cu scriere simultanƒÉ")
    print("=" * 70)

    project_directory = "."  # sau specifica»õi calea cƒÉtre proiect

    # RuleazƒÉ fix-ul complet
    problems_fixed = find_and_fix_all_csv_problems(project_directory)

    if problems_fixed > 0:
        print(f"\nüéâ REPARATE {problems_fixed} PROBLEME!")

        # VerificƒÉ cƒÉ fix-urile au fost aplicate
        if verify_fixes_applied(project_directory):
            print("\n‚úÖ TOATE PROBLEMELE AU FOST ELIMINATE DEFINITIV!")
            print("üéØ Peak »ôi Radius vor fi √éNTOTDEAUNA √Æn pozi»õiile corecte (6-7)")
            print("üîí CSV-ul nu se va mai modifica automat")
            print("üìÅ Fi»ôiere stabile create √Æn: stable_csv_fixes/")
        else:
            print("\n‚ö†Ô∏è Unele probleme nu au fost complet rezolvate")
    else:
        print("\n‚úÖ Nu s-au gƒÉsit probleme de reparat")